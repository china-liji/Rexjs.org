#### Rexjs 的各个时期重大的逻辑版本更迭信息

##### `rex-0.1.0.js`
**解析方案**：正则。

**解析原理**：先将所有大中小括号用`\\\d+`包括，如：`{{}}`将会被替换成`\0{\0\1{\1\1}\1\0}\0`，然后在之后的正则里就可以通过同一数字所包括的括号来确定其对应的另一个括号。

**缺点**：语法解析不明确，误差大。

##### `rex-0.2.0.js`
**解析方案**：正则。

**解析原理**：单功能处进行正则匹配，匹配成功后，将源代码截取，留下未匹配的源代码片段。

**缺点**：语法解析不完整，无法确立上下文关系。

##### `rex-0.3.0.js`
**解析方案**：正则`+`元素`+`非元素性质的自定义事件。

**解析原理**：先用注册标签，合并标签正则，对整个源代码进行匹配，生成一个文档树，然后再使用`TreeWalker`对元素进行访问，并触发对应标签事件。事件处理器中，会对源代码上下文进行检验，而检验时会利用到`DOM`的一些方法，来确定是否是完整的计算式属性。

**备注**：就算是使用`DOM`相关`API`，性能还是非常的好，在源代码少的时候，比现有较流行的解析器的那种字符解析还要快，但有个分水岭，即`2`万源代码以下，这种元素解析更快，`2`万行源代码左右，则差不多，超过`2`万行，速度稍微慢一些，当然，这是`2016`年所测试的数据。

**缺点**：无法解析`ASI`机制。

**示例源码**：
```js
!{
	["say"](what, who){}
};
```

**依赖**`DOM`**判断语法完整性（大致性意思）**：
```js
var element;

// 设置属性，以便使用子元素选择器
object.setAttribute("data-rexjs", "");

// 查询元素
element = obj.querySelector("[data-rexjs] > bracket + parenthesis + brace:last-child, [data-rexjs] > bracket + parenthesis + brace + comma");

// 移除属性
object.removeAttribute("data-rexjs");

// 如果存在，说明是一个完整的表达式
if(element){
	// 进行其他校正或解析
	callback(element);
}
```

##### `rex-0.4.0.js`
**解析方案**：正则`+`元素`+`非元素性质的自定义事件。

**解析原理**：先用注册标签，合并标签正则，使用`RegExp.prototype.exec`与`RegExp.prototype.lastIndex`来解析源代码，匹配到一个就触发对应标签所绑定的事件，然后在绑定事件中对上下文关系进行其他事件监听。

**缺点**：自定义事件机制性能较差，且也无法解析`ASI`机制。

##### `rex-1.0.0.js` 及 以后版本
**解析方案**：正则`+`语法标签`+`语法表达式`+`语法语句`+`语法语句块等等。

**解析原理**：根据最初的标签列表所关联的正则，去匹配源代码，从而获取到对应语法标签，而该语法标签又会返回下一个它自己所需关联的上下文标签列表，如此重复，直至匹配完所有源代码。

**缺点**：使用了比较耗性能的正则匹配组。如：
```js
result = /你()|我()|他()/.exec("我"); // [ "我", undefined, "", undefined ]

index = result.lastIndexOf("") - 1;
```

这样才能获取匹配项的索引，从而才能做接下来的解析，但是这样做无疑消耗了更多性能。

**缺点解决方案**：
1. 原生正则支持根据`|`的分组情况，来告知开发者所匹配到的索引值，如：`index = /你|我|他/.exec("我").groupIndex`。
2. 使用第三方正则类库，非依赖原生正则并重新解析正则的那种类库。如果有朋友发现了类似的类库，请在[issues](https://github.com/china-liji/Rexjs/issues)中留言，谢谢。

**缺点解决后的影响**：`Rexjs`解析性能能提高`20%`左右！