<div>
	<p>
		对象是 JavaScript 中最基本的成员，其最大的特点就是可以进属性访问，而我们几乎无时不刻都要用到这个特点，
		所以，我们在这章谈谈对象的<mark>属性访问性能</mark>。
	</p>
	<p>
		<strong>属性访问层次</strong>：当访问层次越少，速度越快。
		如：<mark>window.location</mark> 速度肯定快于 <mark>window.self.self.self.self.location</mark>。
		原因很简单，就像买火车票，当前面排队的人越多，必须等到大家都买完后，才能轮到你，所以比较耗时。
		而当你想多次买火车票，怎么办？设想一下，如果在第一次到买票窗口的时候，就可以申请一个专属窗口，
		以后只针对你服务，这样是不是方便了许多了呢？恰好，JavaScript 可以给你提供这样一个专属窗口！
		所以，当一个属性将多次被访问，我们应该将它先存起来<mark>var g = obj.a.b.c.d.e.f.g</mark>，
		以便后续多次使用<mark>return g.x + g.y + g.z</mark>。
	</p>
	<p>
		<strong>原型链访问层次</strong>：与上同理，当访问层次越少，速度越快。
		我们先看下图：
		<br />
		<img src="page/strategy/image/object-prototype.png" />
		图中，<mark>A4</mark>类有好几层继承关系，而且<mark>color</mark>属性是定义在<mark>Toy</mark>类上面的，
		并且图中代码最后调用的<mark>a4.color()</mark>方法，是由一层层原型链属性的检测之后，
		最后在<mark>Toy</mark>上面发现该属性后，再执行的。自然，速度肯定是要慢于<mark>new Toy().color()</mark>。
		但是，我们要讲的不是如何优化这种<mark>已知原型链属性</mark>的调用，反之，在逻辑上，并不提倡去优化它，也不好去优化它。
		所以，我们要提的是另一点：不要对<mark>未知属性</mark>（即可能不存在的属性）进行十分频繁的调用，像<mark>var owner = a4.owner || "xx"</mark>这样的属性访问。
		其中<mark>owner</mark>并不存在于对象及原型链上，那么，它经历的便是访问过<mark>a4</mark>对象的<mark>每一层原型链</mark>，
		这是不应该的。针对这种情况，我们建议在<mark>A4</mark>的构造函数中，对这些可能被访问的属性进行初始化<mark>this.owner = "xx"</mark>以替代<mark>a4.owner || "xx"</mark>。
	</p>
	<p>
		<strong>属性获取方式</strong>：属性越直观，速度越快。
		<mark>首先</mark>，直接使用点属性访问器<mark>obj.a</mark>和通过字符串属性获取<mark>obj["a"]</mark>最快，它们是字面量，估计是可以预编译；
		<mark>其次</mark>，使用数字<mark>obj[123]</mark>或数字字符串<mark>obj["123"]</mark>获取，也很快，与第 1 种速度几乎差不多，
		但是当纯数字大于一定长度时<mark>obj[1111111111111]</mark>，速度开始变慢，要比点属性直接访问慢 20 倍以上；
		<mark>再次</mark>，使用带运算的属性获取方式<mark>obj["123" + "456"]</mark>，速度较慢，就算最简单的运算也比点属性直接访问慢 50 倍左右，计算越复杂，速度越慢；
		<mark>然后</mark>，非数字、字符串的属性获取方式<mark>obj[obj]</mark>，更慢，比点属性直接访问慢 80 倍以上，原因是要将属性名先转换成字符串；
		<mark>最后</mark>，非数字、字符串还并带运算<mark>obj[obj + "123"]</mark>，慢慢慢...
	</p>
</div>