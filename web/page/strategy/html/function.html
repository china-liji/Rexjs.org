<div>
	<p>
		函数是 JavaScript 的基本类型之一，其用途非常广，在 ES6 出现以前，它可以代表类、方法、回调等等，无处不在。
	</p>
	<p>
		<strong>函数生成</strong>：在这主要指的是<mark>new Function(code)</mark>，
		使用这种方式生成函数，会有一个特殊阶段，即对<mark>code</mark>的解析与编译，
		这是一个较耗性能的点，而<mark>eval(code)</mark>也是一样。
	</p>
	<p>
		<strong>函数引用</strong>：在 ES6 出现以前，很多人模拟类<mark>A</mark>时候，都在是构造函数内
		<mark>this.setValue = function(value){ this.value = value }</mark>这样来定义类的方法，
		那么大家看下下面这个判断<mark>new A().setValue === new A().setValue</mark>会成立吗？
		答案是肯定不会成立的，因为每次都是一个新的方法，但起到的作用却是一模一样的，还要消耗更多的性能，
		去创建、销毁这个方法函数，所以原型链在这方面的优势就体现出来了<mark>A.prototype.setValue = function(value){ this.value = value }</mark>。
		同理，在类似这样<mark>function outer(arr){ arr.forEach(function(item){ item.i++ }) }</mark>的例子中，
		我们应该把<mark>forEach</mark>方法的回调函数给提取到<mark>outer</mark>函数主体的外层去
		<mark>var callback = function(item){ item.i++ }</mark>，再传入<mark>forEach</mark>方法
		<mark>arr.forEach(callback)</mark>。
	</p>
	<p>
		<strong>call 与 apply</strong>：<mark>call</mark>比<mark>apply</mark>的性能更高。
		因为<mark>apply</mark>是使用的数组，如果参数不是数组，底层代码可能会转换数据类型，导致性能消耗。
		所以，比起<mark>fn.apply(this, arguments)</mark>，更建议使用<mark>fn.call(this, arguments[0], arguments[1], arguments[2])</mark>。
	</p>
</div>